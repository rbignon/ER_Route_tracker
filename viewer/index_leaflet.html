<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elden Ring Route Viewer</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
            height: 100vh;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            border-bottom: 2px solid #c9a227;
        }

        #toolbar h1 {
            font-size: 1.2em;
            color: #c9a227;
            font-weight: normal;
            margin-right: 20px;
        }

        #toolbar button, #toolbar label {
            background: #2a2a4a;
            border: 1px solid #c9a227;
            color: #c9a227;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        #toolbar button:hover, #toolbar label:hover {
            background: #c9a227;
            color: #1a1a2e;
        }

        #toolbar input[type="file"] {
            display: none;
        }

        #info {
            margin-left: auto;
            font-size: 0.85em;
            color: #888;
        }

        #map {
            position: absolute;
            top: 55px;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a2e;
        }

        #route-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid #c9a227;
            z-index: 1000;
            min-width: 250px;
            display: none;
        }

        #route-info h3 {
            color: #c9a227;
            margin-bottom: 10px;
            font-size: 1em;
        }

        #route-info p {
            margin: 5px 0;
            font-size: 0.85em;
            color: #ccc;
        }

        #route-info .stat {
            color: #fff;
            font-weight: bold;
        }

        /* Custom Leaflet styles */
        .leaflet-container {
            background: #1a1a2e;
        }
        
        .start-marker {
            background: #00ff00;
            border: 3px solid #fff;
            border-radius: 50%;
        }
        
        .end-marker {
            background: #ff0000;
            border: 3px solid #fff;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <h1>üó∫Ô∏è Elden Ring Route Viewer</h1>
        <label for="route-file">üìÇ Load Route</label>
        <input type="file" id="route-file" accept=".json">
        <button id="clear-route">üóëÔ∏è Clear</button>
        <button id="focus-route">üéØ Focus Route</button>
        <span id="info">Leaflet.js Tile Map</span>
    </div>

    <div id="map"></div>

    <div id="route-info">
        <h3>Route Info</h3>
        <p>Name: <span id="route-name" class="stat">-</span></p>
        <p>Points: <span id="route-points" class="stat">-</span></p>
        <p>Duration: <span id="route-duration" class="stat">-</span></p>
        <p>Recorded: <span id="route-date" class="stat">-</span></p>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // =============================================================================
        // CONFIGURATION
        // =============================================================================
        
        // Map dimensions (original image)
        const MAP_WIDTH = 15175;
        const MAP_HEIGHT = 14280;
        
        // Tile configuration (will be loaded from metadata.json)
        let TILE_CONFIG = {
            maxZoom: 6,
            tileSize: 256,
            paddedSize: 16384  // 2^6 * 256
        };

        // =============================================================================
        // CALIBRATION (Game coordinates to Pixel coordinates)
        // =============================================================================
        
        const CALIBRATION_POINTS = [
            // Game(X, Z) ‚Üí Pixel(x, y) - Using GLOBAL coordinates
            { gameX: 10740.49, gameZ: 9159.12, pixelX: 5847, pixelY: 11447 },
            { gameX: 10704.96, gameZ: 9296.39, pixelX: 5801, pixelY: 11240 },
            { gameX: 10927.56, gameZ: 9523.99, pixelX: 6135, pixelY: 10886 },
            { gameX: 12396.08, gameZ: 10301.70, pixelX: 8434, pixelY: 9693 },
        ];

        // Affine transform coefficients
        let transform = null;

        function solveLinearSystem(points, getTarget) {
            const n = points.length;
            let sumX = 0, sumZ = 0, sumXX = 0, sumZZ = 0, sumXZ = 0;
            let sumT = 0, sumXT = 0, sumZT = 0;

            for (const p of points) {
                const x = p.gameX, z = p.gameZ, t = getTarget(p);
                sumX += x; sumZ += z;
                sumXX += x*x; sumZZ += z*z; sumXZ += x*z;
                sumT += t; sumXT += x*t; sumZT += z*t;
            }

            const A = [
                [sumXX, sumXZ, sumX],
                [sumXZ, sumZZ, sumZ],
                [sumX,  sumZ,  n]
            ];
            const B = [sumXT, sumZT, sumT];

            // Gaussian elimination
            for (let i = 0; i < 3; i++) {
                let maxRow = i;
                for (let k = i + 1; k < 3; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
                }
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [B[i], B[maxRow]] = [B[maxRow], B[i]];

                for (let k = i + 1; k < 3; k++) {
                    const c = A[k][i] / A[i][i];
                    for (let j = i; j < 3; j++) A[k][j] -= c * A[i][j];
                    B[k] -= c * B[i];
                }
            }

            const x = [0, 0, 0];
            for (let i = 2; i >= 0; i--) {
                x[i] = B[i];
                for (let j = i + 1; j < 3; j++) x[i] -= A[i][j] * x[j];
                x[i] /= A[i][i];
            }
            return x;
        }

        function calculateTransform() {
            if (CALIBRATION_POINTS.length < 2) {
                transform = { a: 1, b: 0, c: MAP_WIDTH/2, d: 0, e: -1, f: MAP_HEIGHT };
                return;
            }

            const [a, b, c] = solveLinearSystem(CALIBRATION_POINTS, p => p.pixelX);
            const [d, e, f] = solveLinearSystem(CALIBRATION_POINTS, p => p.pixelY);
            
            transform = { a, b, c, d, e, f };
            console.log('Transform calculated:', transform);
        }

        function gameToPixel(gameX, gameZ) {
            if (!transform) calculateTransform();
            return {
                x: transform.a * gameX + transform.b * gameZ + transform.c,
                y: transform.d * gameX + transform.e * gameZ + transform.f
            };
        }

        // =============================================================================
        // LEAFLET MAP SETUP
        // =============================================================================
        
        // Our tiles: zoom 0 = 1x1 tile (whole image), zoom 6 = 64x64 tiles
        // Padded image size at max zoom: 16384x16384 pixels
        // 
        // For Leaflet with custom tiles, we need to:
        // 1. Set the coordinate system bounds in "tile units" at max zoom
        // 2. Use the tile coordinates directly
        
        // Create a simple coordinate system where 1 unit = 1 pixel at max zoom
        // At max zoom (6), we have 64 tiles in each direction, each 256px
        // So the map is 16384x16384 units
        
        // Bounds in Leaflet Simple CRS: [y, x] where y increases upward
        // Our image: [0,0] is top-left, y increases downward
        // Leaflet: [0,0] is bottom-left, y increases upward
        // So we use negative y values for our image coordinates
        
        const PADDED_SIZE = 16384;
        const MAX_ZOOM = 6;
        
        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: 0,
            maxZoom: MAX_ZOOM,
            zoomSnap: 0.5,
            zoomDelta: 0.5
        });

        // For CRS.Simple, coordinates are in pixels relative to the top-left at max zoom
        // We set bounds so that the map fills the tile area
        // Using [lat, lng] = [-y, x] convention
        const southWest = map.unproject([0, PADDED_SIZE], MAX_ZOOM);
        const northEast = map.unproject([PADDED_SIZE, 0], MAX_ZOOM);
        const mapBounds = new L.LatLngBounds(southWest, northEast);
        
        // Add tile layer - use standard Leaflet tile URL format
        // Cache buster to force reload of new tiles
        const cacheBuster = Date.now();
        const tileLayer = L.tileLayer(`tiles/{z}/{x}/{y}.jpg?v=${cacheBuster}`, {
            minZoom: 0,
            maxZoom: MAX_ZOOM,
            tileSize: 256,
            noWrap: true,
            bounds: mapBounds
        }).addTo(map);

        // Calculate bounds for actual image (not padded)
        const imageSouthWest = map.unproject([0, MAP_HEIGHT], MAX_ZOOM);
        const imageNorthEast = map.unproject([MAP_WIDTH, 0], MAX_ZOOM);
        const imageBounds = new L.LatLngBounds(imageSouthWest, imageNorthEast);
        
        // Fit view to actual image bounds and restrict navigation to it
        map.fitBounds(imageBounds);
        map.setMaxBounds(imageBounds.pad(0.02)); // Small padding to avoid edge issues

        // =============================================================================
        // ROUTE HANDLING
        // =============================================================================
        
        let currentRoute = null;
        let routeLayer = null;
        let startMarker = null;
        let endMarker = null;

        function pixelToLatLng(pixelX, pixelY) {
            // Convert pixel coordinates to Leaflet LatLng using unproject
            // This handles the coordinate system conversion properly
            return map.unproject([pixelX, pixelY], MAX_ZOOM);
        }

        function clearRoute() {
            if (routeLayer) {
                map.removeLayer(routeLayer);
                routeLayer = null;
            }
            if (startMarker) {
                map.removeLayer(startMarker);
                startMarker = null;
            }
            if (endMarker) {
                map.removeLayer(endMarker);
                endMarker = null;
            }
            currentRoute = null;
            document.getElementById('route-info').style.display = 'none';
        }

        function drawRoute(route) {
            clearRoute();
            
            if (!route || !route.points || route.points.length < 2) {
                console.warn('Invalid route data');
                return;
            }

            currentRoute = route;
            const points = route.points;
            
            // Convert game coordinates to Leaflet coordinates
            const latLngs = points.map(p => {
                const pixel = gameToPixel(p.global_x, p.global_z);
                return pixelToLatLng(pixel.x, pixel.y);
            });

            // Draw route polyline
            routeLayer = L.polyline(latLngs, {
                color: '#00ff00',
                weight: 6,
                opacity: 0.8,
                lineJoin: 'round',
                lineCap: 'round'
            }).addTo(map);

            // Add glow effect with a wider, semi-transparent line behind
            L.polyline(latLngs, {
                color: '#00ff00',
                weight: 12,
                opacity: 0.3,
                lineJoin: 'round',
                lineCap: 'round'
            }).addTo(map);

            // Start marker (green)
            const startPixel = gameToPixel(points[0].global_x, points[0].global_z);
            startMarker = L.circleMarker(pixelToLatLng(startPixel.x, startPixel.y), {
                radius: 12,
                fillColor: '#00ff00',
                color: '#ffffff',
                weight: 3,
                opacity: 1,
                fillOpacity: 1
            }).addTo(map);
            startMarker.bindPopup('<b>Start</b><br>Point 1');

            // End marker (red)
            const endPixel = gameToPixel(points[points.length-1].global_x, points[points.length-1].global_z);
            endMarker = L.circleMarker(pixelToLatLng(endPixel.x, endPixel.y), {
                radius: 12,
                fillColor: '#ff0000',
                color: '#ffffff',
                weight: 3,
                opacity: 1,
                fillOpacity: 1
            }).addTo(map);
            endMarker.bindPopup('<b>End</b><br>Point ' + points.length);

            // Update info panel
            document.getElementById('route-info').style.display = 'block';
            document.getElementById('route-name').textContent = route.name || 'Unnamed';
            document.getElementById('route-points').textContent = route.point_count || points.length;
            document.getElementById('route-duration').textContent = 
                route.duration_secs ? `${Math.floor(route.duration_secs / 60)}m ${Math.floor(route.duration_secs % 60)}s` : '-';
            document.getElementById('route-date').textContent = route.recorded_at || '-';

            console.log('Route drawn:', points.length, 'points');
        }

        function focusRoute() {
            if (routeLayer) {
                map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
            }
        }

        // =============================================================================
        // EVENT HANDLERS
        // =============================================================================
        
        // File input
        document.getElementById('route-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const route = JSON.parse(event.target.result);
                    console.log('Loaded route:', route.name);
                    drawRoute(route);
                    focusRoute();
                } catch (err) {
                    console.error('Parse error:', err);
                    alert('Error parsing route file: ' + err.message);
                }
            };
            reader.readAsText(file);
        });

        // Clear button
        document.getElementById('clear-route').addEventListener('click', clearRoute);

        // Focus button
        document.getElementById('focus-route').addEventListener('click', focusRoute);

        // =============================================================================
        // INITIALIZATION
        // =============================================================================
        
        // Load tile metadata if available
        fetch('tiles/metadata.json')
            .then(r => r.json())
            .then(meta => {
                console.log('Tile metadata loaded:', meta);
                TILE_CONFIG = {
                    maxZoom: meta.max_zoom,
                    tileSize: meta.tile_size,
                    paddedSize: meta.padded_size
                };
            })
            .catch(() => {
                console.log('No tile metadata, using image overlay fallback');
                imageOverlay.addTo(map);
            });

        // Initialize transform
        calculateTransform();
        console.log('Elden Ring Route Viewer initialized');
    </script>
</body>
</html>


